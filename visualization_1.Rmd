---
title: "visualiztion_1"
author: "Ziqing Wang"
date: "2022-09-29"
output: github_document
---

```{r, include=FALSE}
library(tidyverse)
library(ggridges)
```

```{r import data}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728", "USC00519397", "USS0023B17S"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(
      id, 
      USW00094728 = "CentralPark_NY", 
      USC00519397 = "Waikiki_HA",
      USS0023B17S = "Waterhole_WA"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
weather_df
```

```{r basic scatterplot}
ggplot(weather_df, aes(x = tmin, y = tmax)) + geom_point()
```
You can also use the %>% pipe to process the data before making a plot (if you don't want to save the intermediate dataset).

ggplot objects can also be saved as variables in the environment.

Color the scatterplot by names of weather station:
```{r more advanced scatterplot}
ggplot(weather_df, aes(x=tmin, y=tmax)) + geom_point(aes(color=name))
```
Add smooth approximations scatterpoints categorized by names of weather station, and make the points more transparent:
```{r}
ggplot(weather_df, aes(x=tmin, y=tmax, color=name)) +
  geom_point(alpha=0.5) + 
  geom_smooth(se=FALSE)
```
Add one smooth approximation to all scatterpoints by changing the location of color=name:
```{r}
ggplot(weather_df, aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5) +
  geom_smooth(se = FALSE)
```

Use facet grid to create and arrange multiple panels:
```{r}
ggplot(weather_df, aes(x=tmin, y=tmax, color=name)) + 
  geom_point(alpha=0.5) +
  geom_smooth(se=FALSE) +
  facet_grid(. ~ name)
```

Seasonal trend of the maximum temperature:
```{r}
ggplot(weather_df, aes(x=date, y=tmax, color=name)) +
  geom_point(aes(size=prcp), alpha=0.5) +
  geom_smooth(se=F) + 
  facet_grid(. ~ name) + 
  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))
  
```

When you’re making a scatterplot with lots of data, there’s a limit to how much you can avoid overplotting using alpha levels and transparency. In these cases geom_hex(), geom_bin2d(), or geom_density2d() can be handy:
```{r}
ggplot(weather_df, aes(x = tmax, y = tmin)) + 
  geom_hex() # hex as in hexagon
```

Some univariate plots:
```{r}
ggplot(weather_df, aes(x = tmax)) + 
  geom_histogram()
```

```{r}
ggplot(weather_df, aes(x = tmax, fill = name)) + 
  geom_histogram(position = "dodge", binwidth = 2)
```

```{r}
ggplot(weather_df, aes(x = tmax, fill = name)) + 
  #geom_density(alpha = .4, adjust = .5, color = "blue")
  geom_histogram() +
  facet_grid(. ~ name)

```

The position = "dodge" places the bars for each group side-by-side, but this gets sort of hard to understand. I often prefer density plots in place of histograms.
```{r}
ggplot(weather_df, aes(x = tmax, fill = name)) + 
  geom_density(alpha = .4, adjust = .5, color = "blue")
```

Histograms and densities are one way of investigating univariate distributions; boxplots are another.
```{r}
ggplot(weather_df, aes(x = name, y = tmax)) + geom_boxplot()

```

Violin plots are sometimes nice, but folks complain that they don’t look like violins.
They can be useful if you are comparing a lot more tham 3 categories.

```{r}
ggplot(weather_df, aes(x = name, y = tmax)) + 
  geom_violin(aes(fill = name), alpha = .5) + 
  stat_summary(fun = "median", color = "blue")

```
Ridge plots were the trendiest plot of 2017, and were a replacement for both boxplots and violin plots. They’re implemented in the ggridges package, and are nice if you have lots of categories in which the shape of the distribution matters.

```{r}
ggplot(weather_df, aes(x = tmax, y = name)) + 
  geom_density_ridges(scale = .85)

```

You will, on occasion, need to save a plot to a specific file. Don’t use the built-in “Export” button! If you do, your figure is not reproducible – no one will know how your plot was exported. Instead, use ggsave() by explicitly creating the figure and exporting; ggsave will guess the file type you prefer and has options for specifying features of the plot. In this setting, it’s often helpful to save the ggplot object explicitly and then export it (using relative paths!).

```{r}
weather_plot = ggplot(weather_df, aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name), alpha = .5) 

ggsave("weather_plot.pdf", weather_plot, width = 8, height = 5)

```

You can also embad plots in the knitted file?
```{r}
knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)
```
What makes embedding figures difficult at first is that things like the font and point size in the figures generated by R are constant – that is, they don’t scale with the overall size of the figure. As a result, text in a figure with width 12 will look smaller than text in a figure with width 6 after both have been embedded in a document. As an example, the code chunk below has set fig.width = 12

```{r}
ggplot(weather_df, aes(x = tmin, y = tmax)) + 
  geom_point(aes(color = name))

```

